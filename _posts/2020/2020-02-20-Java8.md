---
layout: post
title: java8新特性
category: interview
---
## 一、lambda表达式
 lambda表达式需要函数式接口（接口中只有一个抽象方法）的支持 @FunctionalInterface可用来检查
 java8中引入的新的操作符 “->” 箭头操作符或lambda操作符

 四大核心内置函数型接口
 1. Consumer<T> 消费型接口
       void accept(T t);
 2. Supplier<T> ：供给型接口
      T get();
 3. Function<T,R> ：函数型接口
      R apply(T t);
 4. Predicate<T> ：断言型接口
      boolean test(T t);
左右遇一括号省
左侧类型推断省 能省则省

## 二、方法引用
 * 方法引用：若lambda体中的内容有方法已经有实现了，我们可以使用方法引用
 （可以理解为是lambda的另一种表现形式）
 主要有三种语法格式
 1. 对象::实例方法名
 2. 类::静态方法名
 //注意：lambda体中调用方法的参数类型和返回值类型 要和函数式接口中的抽象方法的参数类型和返回值类型相同
         Comparator<Integer> com = (x, y) -> Integer.compare(x, y);
         Comparator<Integer> com1 = Integer::compare;
 3. 类::实例方法名
 第一个参数是实例方法的调用者，第二个参数是实例方法的参数可以使用
                    //若lambda 参数列表的
                    BiPredicate<String, String> bi = (x, y) -> x.contains(y);
                    BiPredicate<String, String> bi1 = String::contains;
 * 二、构造器引用
  类名：：new 构造函数的参数列表要和抽象方法参数列表一致
                 Supplier<Employee> sup1 = Employee::new;
                 Function<Integer, Employee> fun = (x) -> new Employee(x);
                 Function<Integer, Employee> fun1 = Employee::new;
                 fun1.apply(22);
 * 三、数组引用
  Type[]：：new
Function<Integer,String[]> function=(x)->new String[x];
        Function<Integer,String[]> function2=String[]::new;
        function.apply(10);
## 三、Stream API
* 创建Stream
  1. 通过Collection 系列集合提供的stream() 或者parallelStream()
        ArrayList list = new ArrayList<>();
        Stream stream = list.stream();

  2. 通过Array中的静态方法stream()获取流
        String[] strings = new String[3];
        Stream<String> stream1 = Arrays.stream(strings);

  3. 通过Stream类中的静态方法of()
        Stream<String> stream2 = Stream.of("22", "ss");

  4. 创建无限流 迭代
        Stream<Integer> stream3 = Stream.iterate(0, (x) -> x + 2);
        stream3.limit(10).forEach(System.out::println);

        //生成
        Stream<Double> stream4 = Stream.generate(() -> Math.random()*100);
        stream4.limit(6).forEach(System.out::println);
* 中间操作
* 最终操作

## 并行流和串行流
 java8 parallel底层是fork/join框架
 sequential顺序流
## Optional容器类
可有可无的用Optional包装一下

接口中可以有默认方法与静态方法
原来只可以有抽象方法全局静态常亮
005

## 新时间日期API
线程安全？并方便
ThreadLocal可解决安全问题

 